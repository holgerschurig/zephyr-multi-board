#+AUTHOR: Holger Schurig
#+OPTIONS: ^:nil
#+MACRO: relref @@hugo:[@@ $1 @@hugo:]({{< relref "$2" >}})@@
#+HUGO_BASE_DIR: ~/src/hpg/

* Zepyhr: reproducible project setup
:PROPERTIES:
:EXPORT_HUGO_SECTION: en
:EXPORT_FILE_NAME: en/zephyr-reproducible-project-setup.md
:EXPORT_DATE: 2024-01-02
:EXPORT_HUGO_TAGS: zephyr make west OpenOCD
:EXPORT_HUGO_CATEGORIES: embedded
:END:

This blog post shows you how to *reproducibly* setup a Zephyr project. It also gives
you a few Makefile tricks and best practices.

While you can do this by hand, e.g. by following the [[https://docs.zephyrproject.org/latest/develop/getting_started/index.html][Getting Started Guide]], a
reproducible & automatic setup still has benefits. For once, any change you do
is automatically documented in GIT. And also it's much easier to move the
project onto CI/CD servers or into Docker containers.

#+hugo: more
#+toc: headlines 2

** (Ab)use of Makefiles

All of the following is orchestrated mostly by a Makefile.

Even when Zephyr itself uses CMake and Ninja, Makefiles are a nicer way to
bundle lots of shell snippets into one place. You can view this Makefile also
as a collection of knowledge, or as a way to have things replicatable.

The full Makefile is accessible as
https://github.com/holgerschurig/zephyr-multi-board/blob/main/Makefile.zephyr_init

** Basic project setup
*** Make sure you have all dependencies installed

Execution: either "=make init=" or, as a single step, "=make debs=".

How?

#+begin_example -r
UID := $(shell id -u)                                      (ref:isroot)

debs .west/stamp.debs:
ifeq ($(UID),0)                                            (ref:checkroot)
	apt install -y --no-install-recommends \               (ref:apt)
		build-essential \
		ccache \
		cmake \
		device-tree-compiler \
		dfu-util \
		doxygen \
		file \
		g++-multilib \
		gcc \
		gcc-arm-none-eabi \
		gcc-multilib \
		gdb-multiarch \
		git \
		gperf \
		graphviz \
		libmagic1 \
		libnewlib-arm-none-eabi \
		libsdl2-dev \
		make \
		ninja-build \
		openocd \
		plantuml \
		python3-cbor \
		python3-click \
		python3-cryptography \
		python3-dev \
		python3-intelhex \
		python3-pip \
		python3-setuptools \
		python3-tk \
		python3-venv \
		python3-wheel \
		quilt \
		wget \
		xz-utils \
		zip
else
	sudo $(MAKE) --no-print-directory debs               (ref:sudo)
	mkdir -p .west
	touch .west/stamp.debs
endif
#+end_example

Here we use a trick: the Makefile detects in line [[(isroot)]] the user ID of the current user. In line
[[(checkroot)]] we when check if the Makefile is running as user or root. If it is running as root, we
can use "=apt=" in line [[(apt)]] to install all the needed dependencies.

However, if we're a normal user, we use "=sudo=" at line [[(sudo)]] to become root
and run the Makefile target "debs" again. The "=--no-print-directory=" command line argument
just removes visual clutter.

Finally, as a normal user, we create a directory if it doesn't yet exist ("=-p")
and put a stamp file into it. "=make init=" checks this stamp, if the stamp
exists, it won't rerun this part. However, "=make debs=" doesn't check the
stamp, it always runs "=apt=". Use this if for some reason you want to install
additional debian packages in an already setup project.

*** Setting up a python virtual environment

Zephyr needs a tool called "=west=" which is written in Python and get's installed
via "=pip3=", together with several python modules. In order to have these modules
not interfere with those installed by Debian (or Ubuntu), we need to create a virtual
environent.

Execution: either "=make init=" or, as a single step, "=make debs=".

How?

#+begin_example -r
PWD := $(shell pwd)

.PHONY:: venv
init venv:: .west/stamp.debs
ifeq ("$(wildcard .venv/bin/activate)","")              (ref:filexists)
	python3 -m venv $(PWD)/.venv                        (ref:venv)
endif
ifeq ("$(VIRTUAL_ENV)", "")                             (ref:envexists)
	@echo ""
	@echo "... ideally by sourcing all environments: source .env"
	@echo ""
	@exit 1
endif

help::
	@echo "   venv               create and check Python3 virtual environment"
#+end_example

In line [[(filexists)]] we check if the environment already exists (we could use Make's dependency
checking, but it will not just look at the mere existence, but also on the timestamp, which here
is undersirable).

If it doesn't exists, we use the Python "=venv=" module in line [[(venv)]] to simply create one. Now
we could source "=.venv/bin/activate=" to activate this... but unfortunately, this has to be done
outside of Make. Also, we ask to source "=.env=" instead, so that we can also setup needed
[[https://docs.zephyrproject.org/latest/develop/env_vars.html][Zephyr environment variables]].

Pro tip: on my development PCs, I have a shell function "=pro=" that changes into a project directory
and sources "=.env=" automatically if it exist. It looks like this:

#+begin_example -r shell
pro ()
{
    cd ~/src/$1 2> /dev/null || cd ~/d/$1 2> /dev/null || cd /usr/src/$1;
    test -f .env && . .env
}
#+end_example

So now I can do "=pro cool-zephyr-project=" and my environment is automatically setup.

(This shell function assumes that you have your projects in your home directory
below the "=d=" (like development) or "=src=" directories. Adjust as needed.)

*** Install the "=west=" tool

Now that we have a virtual environent, we can install the "=west=" tool.

Execution: either “make init” or, as a single step, “make west”.

How?

#+begin_example -r
.PHONY:: west
init:: .west/config
west .west/config:
	@type west >/dev/null || pip3 install west pyelftools
	mkdir -p .west
	/bin/echo -e "[manifest]\npath = zephyr\nfile = west.yml\n[zephyr]\nbase = zephyr" >.west/config
#+end_example

Actually this does 3 steps:

- install west
- install pyelftools (needed on Debian Bookworm, as the distro provided ones are too old)
- configure Zephyr via "=.west/config="

*** Install Zephyr

Now we need the source of Zephyr. On some projects, you want the current development
version of it, on some projects you want pin yourself to a specific version. You also
might have local patches for Zephyr that you don't want to publish upstream and that
you want to apply automatically. This step does all of this!

BTW, because of these additional functions (specific version, patches) we intentionally
don't use "=west init=".

Execution: either “make init” or, as a single step, “make zephyr”.

How?

#+begin_example -r
#ZEPHYR_VERSION=zephyr-v3.5.0-3531-g6564e8b756                 (ref:zephvers)

.PHONY:: zephyr
init:: zephyr/.git/HEAD
zephyr zephyr/.git/HEAD:
	git clone https://github.com/zephyrproject-rtos/zephyr.git
ifneq ("$(ZEPHYR_VERSION)", "")                                (ref:zephbranch)
	cd zephyr; git checkout -b my $(ZEPHYR_VERSION)
endif
ifneq ("$(wildcard patches-zepyhr/series)","")                 (ref:zephpatches)
	ln -s ../patches-zephyr zephyr/patches
	cd zephyr; quilt push -a                                   (ref:zephpatches2)
endif
#+end_example

The first step is a very normal "=git clone=". If you don't care about Zephyr's commit
history (e.g. you don't want to run things like "=git log=" or "=git blame=" you can also
add "--depth 1". That reduces the size of the cloned "=zephyr/=" directory.

You can uncommend and modify ZEPHYR_VERSION in line [[(zephvers)]] to your liking.
This will pin Zephyr to the specified version. This is done by creating a branch "=my="
in line [[(zephbranch)]].

What you in ZEPHYR_VERSION is the output of "=git describe --tags=" while I was
in the "=zephyr/=" directory at the point of time where one of my projects moved
from EVT to DVT phase. But you can also simply use tag names from the Zephyr
project.

In one of my projects, I have patches that will probably never be accepted by upstream
Zephyr. I however also don't want to commit them into the "=zephyr/=" project. Instead
I use the "=quilt=" tool to have a stack of patches. BTW, Debian (and thus Ubuntu) also use
quilt to patch upstream source packages before making "=.deb=" files, see their
[[https://wiki.debian.org/UsingQuilt][howto]] on it.

The existence of quilt patches is checked in line [[(zephpatches)]] and then just
rolled in in line [[(zephpatches2)]].

*** Install needed Zephyr modules, e.g. HALs from the µC vendor
Some (actually almost all) of the SOCs that Zephyr supports need HALs (hardware
abstraction layers) provided by the chip vendor. If they don't exist, we cannot
compile at all. So let's install them!

Execution: either “make init” or, as a single step, “make modules”.

How?

#+begin_example -r
.PHONY:: modules

init:: modules/hal/stm32/.git/HEAD
.PHONY:: module_stm32
update modules module_stm32 modules/hal/stm32/.git/HEAD:: .west/config
	mkdir -p modules
	west update hal_stm32
	touch --no-create modules/hal/stm32/.git/HEAD

init:: modules/hal/st/.git/HEAD
.PHONY:: module_st
update modules module_st modules/hal/st/.git/HEAD:: .west/config
	mkdir -p modules
	west update hal_st
	touch --no-create modules/hal/st/.git/HEAD

init:: modules/hal/cmsis/.git/HEAD
.PHONY:: module_cmsis
update modules module_cmsis modules/hal/cmsis/.git/HEAD:: .west/config
	mkdir -p modules
	west update cmsis
	touch --no-create modules/hal/cmsis/.git/HEAD
#+end_example

As usual, I made the Makefile so that "=make init=" only pulls in the modules
once. However "=make modules=" will always pull them in, should the vendor have
changed them.

Theoretically one could pin the modules also to specific version, like in the
step above. I however noticed that they are quite stable and this was never
needed. And also I need to have something to assign to you as homework, didn't I
????

** Getting help

If you look at the actual [[https://github.com/holgerschurig/zephyr-multi-board/blob/main/Makefile.zephyr_init
][Makefile]], you'll notice that I ommited a whole lot of lines like

#+begin_example -r
help::
	@echo "   modules            install Zeyphr modules (e.g. ST and STM32 HAL, CMSIS ...)"
#+end_example

from above. They aren't strictly necessary, but nice. They allow you to run "=make help=" and
see all the common makefile targets meant for users. Like so:

#+begin_example -r
(.venv) holger@holger:~/src/multi-board-zephyr$ make -f Makefile.zephyr_init help
init                  do all of these steps:
   debs               only install debian packages
   venv               create and check Python3 virtual environment
   west               install and configure the 'west' tool
   zephyr             clone Zephyr
   modules            install Zeyphr modules (e.g. ST and STM32 HAL, CMSIS ...)
     module_stm32     update only STM32 HAL
     module_st        update only ST HAL
     module_cmsis     update only CMSIS
#+end_example

** All of the above

The individual targets like "=make venv=" or "=make debs=" are mostly only for
debugging. Once you know they are working, simply run: "=make init=".

** Using this makefile in your project

You can simply add your own clauses at the end of this Makefile ... your you can include it from
a main Makefile. This is demonstrated in the Github project https://github.com/holgerschurig/zephyr-multi-board/:

Main "=Makefile="

#+begin_example -r
PWD := $(shell pwd)
UID := $(shell id -u)

.PHONY:: all
all::


# Include common boilerplate Makefile to get Zephyr up on running
include Makefile.zephyr_init

# ... many more lines ...
#+end_example

First at the top we set two environment variables that we often use, PWD
(working directory) and UID (user id). You can then later just use them via
"$(PWD)" --- note that Make want's round brances here, not curly braces like
Bash.

Then I set a default target, to be executed if you just run "=make=" without specifying
a target by yourself.

The double colon here needs to be used for all targets that are defined more
than once in a Makefile. As you see, here the target is empty. It's fleshed out
in much more complexity below, but this is beyond this blog post.

Also note the "=.PHONY:: all=" line. It helps Make to understand that "=make="
or "=make all=" isn't supposed to actually create file called "=all=". This
helps it's dependency resolvement engine, and is good style. My makefile uses
"=.PHONY::=" liberally, for each pseudo-target (shell script snippet) basically.

Finally, we use Make's "=include=" clause to include our boilerplate Makefile.

You could also run the Boilerplate makefile itself, with "=make -f
Makefile.zephyr_init=", e.g. for debugging purposes. But oh ... now PWD and UID
aren't set. So at the top of this makefile I set these variables if they don't exist:

#+begin_example -r
ifeq ($(PWD),"")
PWD := $(shell pwd)
endif
ifeq ($(UID),"")
UID := $(shell id -u)
endif
#+end_example


* Zepyhr: multi-board setup
:PROPERTIES:
:EXPORT_HUGO_SECTION: en
:EXPORT_FILE_NAME: en/zephyr-multi-board.md
:EXPORT_DATE: 2024-01-03
:EXPORT_HUGO_TAGS: zephyr make west OpenOCD
:EXPORT_HUGO_CATEGORIES: embedded
:END:

This blog post shows how to setup a Zephyr project that you can use for several boards.

#+hugo: more
#+toc: headlines 2

** Why multiple boards in one project?

- you start with a development board (like STM Nucleo or Disco) while you wait
  for the actual hardware prototype
- you want to run (hardware-independent) [[https://docs.zephyrproject.org/latest/develop/test/ztest.html][unit-tests]], either on your desktop or
  on a CI/CD server like Jenkings
- you have to develop for many similar devices that only have slight differences
  and don't want to have many almost-identical source trees

** (Ab)use of Makefiles

Most of the following is orchestrated mostly by a Makefile.

Even when Zephyr itself uses CMake and Ninja, Makefiles are a nicer way to
bundle lots of shell snippets into one Makefile. You can view this Makefile also
as a collection of knowledge, or as a way to have things replicatable.

** This blog post is based on ...

This blog post depends on Macro test {{{relref(Zepyhr: reproducible project
setup,zephyr-reproducible-project-setup)}}} and uses it's [[https://github.com/holgerschurig/zephyr-multi-board/blob/main/Makefile.zephyr_init][Makefile.zephyr_init]].

** Board related
*** Get list of defined board

Now that you created the Zephyr development environment using {{{relref(Zepyhr:
reproducible project setup,zephyr-reproducible-project-setup)}}}, added some
sources and a "=CMakeLists.txt=" file you enter "=make=" to compile your
project.

But instead of compiling your source, you see a list of available boards:

#+begin_example
:~/src/multi-board-zephyr$ make

-----------------------------------------------------------------------------

You must first select with with board you want to work:

native                configure for native (used for unit-tests)
nucleo                compile for STM32 Nucleo
local                 configure for locally defined board

-----------------------------------------------------------------------------

#+end_example

The reason is that we don't yet know for which board you actually want to
compile your sources.

Basically, if no "=build/=" directory exists, you get this help text with all
configured boards inside the Makefile.

*** Configure and compile for one of the boards

So instead, select board, and enter "=make nucleo=" instead. And now Zephyr
configures itself and compiles:

#+begin_example -r
~/src/multi-board-zephyr$ make nucleo
west build \
	--pristine \                                 (ref:pristine)
	-b nucleo_f303re \                           (ref:nucleo_f303re)
	-o "build.ninja" \                           (ref:ninja)
	-- \                                         (ref:cmake)
	-Wno-dev \
	-Wno-deprecated \
	-DCMAKE_EXPORT_COMPILE_COMMANDS=ON \         (ref:lsp)
	-DOVERLAY_CONFIG="nucleo_f303re.conf"        (ref:overlay)
-- west build: generating a build system
Loading Zephyr default modules (Zephyr base).
-- Application: /home/holger/src/multi-board-zephyr
# ... many more lines ...
#+end_example

There are some special things here at work:

- in line [[(pristine)]] we order "=west=" to use a pristine environment whenever
  the configuration changes. So you can do "=make local=" and then "=make
  nucleo=" and the "=build/=" directory will completely switch. While you can do
  "=rm -rf build=" you don't need to, due to this "=--pristine=" command line
  switch
- in line [[(nucleo_f303re)]] we actually select the wanted boards. This one is
  provided by Zephyr itself, you can find it in
  https://github.com/zephyrproject-rtos/zephyr/tree/main/boards/arm/nucleo_f303re
- line [[(ninja)]] tells Zephyr's CMake to use Ninja, which is faster compiling
  compared to let CMake generate Makefiles.
- the two dashes in line [[(cmake)]] tells "=west=" to pass over all the future command
  line-options as-is to CMake.
- line [[(lsp)]] tells CMake to generate a compilation database. Use this with an
  LSP daemon like clangd or other tools that depend it. Many editors like Emacs,
  Visual Studio etc offer special services if LSP is present.
- line [[(overlay)]] tell the build system to configure itself according to this
  config files (which has Linux KConfig / "=.config=" syntax. Note that only
  board-specific configuration should be placed there. Anything that should be
  used project-wide has a better place in "=prj.conf=".

If the configuration step succeed, this will also automatically compile your code.

Here are the last few lines of the compilation process:

#+begin_example
Memory region         Used Size  Region Size  %age Used
           FLASH:       39782 B       512 KB      7.59%
             RAM:        9792 B        64 KB     14.94%
             CCM:          0 GB        16 KB      0.00%
        IDT_LIST:          0 GB         2 KB      0.00%
Generating files from /home/holger/src/multi-board-zephyr/build/zephyr/zephyr.elf for board: nucleo_f303re
[147/147] cd /home/holger/src/multi-board-zephyr/b...ger/src/multi-board-zephyr/build/zephyr/zephyr.el
(.venv) holger@holger:~/src/multi-board-zephyr$ file build/zephyr/zephyr.bin
build/zephyr/zephyr.bin: ARM Cortex-M firmware, initial SP at 0x20001fc0, reset at 0x08002f30, NMI at 0x08002bec, HardFault at 0x08002f1c, SVCall at 0x08003054, PendSV at 0x08002fec
#+end_example

*** How this is implemented

The above "=make nucleo=" is implemented by this Makefile part:

#+begin_example
.PHONY:: nucleo
nucleo: .west/config
	west build \
		--pristine \
		-b nucleo_f303re \
		-o "build.ninja" \
		-- \
		-Wno-dev \
		-Wno-deprecated \
		-DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
		-DOVERLAY_CONFIG="nucleo_f303re.conf"
	west build

help help_boards::
	@echo "nucleo                compile for STM32 Nucleo"
#+end_example

Note the last two lines: we have a Makefile pseudo-target "=help_boards=" which
can exist several times in the Makefile (because it uses "::" and not ":"). Each of our board
configuration snippets contains such an entry.

Now, if you simply run "=make=", then the pseudo-target "all" will be executed.
And it looks like this:

#+begin_example -r
all::
ifeq ("$(wildcard build/build.ninja)","")           (ref:build.ninja)
	@$(call show_boards)
else
	ninja -C build                                  (ref:runninja)
endif
#+end_example

- in line [[(build.ninja))] it checks if the build environment inside the
  "=build/=" directory has been created. If not, it calls the Make function
  "show_boards". More on this function in a moment.
- but if it exists, we just call in line [[(runninja)]] "=ninja=" with our build
  directory as working dir

The make function is simple enought: basically only some decoration around "=make help_boards=":

#+begin_example
define show_boards
	@echo ""
	@echo "-----------------------------------------------------------------------------"
	@echo ""
	@echo "You must first select with with board you want to work:"
	@$(MAKE) --no-print-directory help_boards
	@echo ""
	@echo "-----------------------------------------------------------------------------"
	@echo ""
endef
#+end_example

The reason I made this a function is so that it is easy to call from several
places. In this Makefile, not only "=make all=" calls it eventually, but also
maybe "=make menuconfig=" or "=make xconfig=".

*** Configure and compile for simulated hardware

Zephyr includes a "board" called [[https://docs.zephyrproject.org/latest/boards/posix/native_sim/doc/index.html][native_sim]]. Basically your sources are compiled
for this target, but they run on your development computer (e.g. compiled to
x86, not for ARM). The native simulator even allows you to similar some
hardware, e.g. an AT24 EEPROM.

However, what is most useful is that you can define unit-tests and run these unit-tests
than on your develpment compiter --- or on a CI/CD server, like Jenkins.

Here is how you configure Zephyr for this:
#+begin_example -r
.PHONY:: native
native: .west/config
	west build \
		--pristine \
		-b native_sim \
		-o "build.ninja" \
		-- \
		-DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
		-DOVERLAY_CONFIG="native_sim.conf"              (ref:nativesim)
	west build
#+end_example

As before, any native-sim-related configuration should be put into
="native_sim.conf=", (line [[(nativesim)]]).

Now, when we configure and compile, we now get a binary that we can run under
Linux (or WSL, if you're on Windows):

#+begin_example
$ make native
west build \
	--pristine \
	-b native_sim \
	-o "build.ninja" \
	-- \
	-DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
	-DOVERLAY_CONFIG="native_sim.conf"
-- west build: making build dir /home/holger/src/multi-board-zephyr/build pristine
-- west build: generating a build system
Loading Zephyr default modules (Zephyr base).
-- Application: /home/holger/src/multi-board-zephyr

# ... many lines omitted ...

[93/93] cd /home/holger/src/multi-board-zephyr/bui...ger/src/multi-board-zephyr/build/zephyr/zephyr.ex
#+end_example

It's even named "=*.exe=" :-)

#+begin_example
$ file build/zephyr/zephyr.exe
build/zephyr/zephyr.exe: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=d4b863c9b8d6e9e2265fdef874ec0b9df70efdc9, for GNU/Linux 3.2.0, with debug_info, not stripped
#+end_example

And you can call it normally:

#+begin_example
~/src/multi-board-zephyr$ build/zephyr/zephyr.exe
Running TESTSUITE tests
===================================================================
START - demo_test
 PASS - demo_test in 0.000 seconds
===================================================================
TESTSUITE tests succeeded

------ TESTSUITE SUMMARY START ------

SUITE PASS - 100.00% [tests]: pass = 1, fail = 0, skip = 0, total = 1 duration = 0.000 seconds
 - PASS - [tests.demo_test] duration = 0.000 seconds

------ TESTSUITE SUMMARY END ------

===================================================================
PROJECT EXECUTION SUCCESSFUL
#+end_example

I will create another blog soon on how to integrate this into Jenkings: by
converting the output into the TAP format.

*** Define a local board

So far, we used boards already defined by the Zephyr source code. But perhaps
you want to use Zephyr on one of your own boards, where you don't plan to
publish it upstream? That's entirely possible, and the board called "local" of this project is exactly that: a board defined for Zephyr, but out-of-tree.

The Makefile snippet for it sounds familiar ...

#+begin_example -r
.PHONY:: local
local: .west/config
	west build \
		--pristine \
		-b local \
		-o "build.ninja" \
		-- \
		-DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
		-DOVERLAY_CONFIG="boards/arm/local/local_defconfig" \      (ref:defconfig)
		-DBOARD_ROOT=.                                             (ref:boardroot)
	west build
#+end_example

... but there is some differences:

- line [[(defconfig)]] gives a full path to the default config of the board
- line [[(boardroot)]] specifies OUR project (not Zephyr) as the board root. So
  Zephyr won't look into "=zephyr/boards/...=" but instead into "=boards/...="
  when looking for boards.

Now we need to have such a "=boards/arm/local/=" directory and populate it with some files:

| File                | Purpose                                                                                          |
| Kconfig.board       | this is where you introduce board-specific Kconfig options                                       |
| Kconfig.defconfig   | without setting CONFIG_BOARD to the name of your board, Zephyr wouldn't find the following files |
| board.cmake         | can contain CMake definitions, usually used for OpenOCD or JLink settings                        |
| local.dts           | the Device Tree for your board                                                                   |
| local_defconfig     | the default configuaration for your board, only put things there that isn't in "=prj.conf="      |
| support/openocd.cfg | if you use OpenOCD, this contains configuration for it                                           |

*** Compiling some sources only for some boards

This can easily be done via "=CMakeLists.txt=":

#+begin_example -r
target_sources(app PRIVATE
  main.c)                                                          (ref:src_main)

target_sources_ifdef(CONFIG_BOARD_LOCAL app PRIVATE                (ref:src_local)
  board_local.c)

target_sources_ifdef(CONFIG_BOARD_NATIVE_SIM app PRIVATE           (ref:src_native)
  board_native.c)
#+end_example

- any sources that must compile for every board is specified like in line
  [[(src_main)]]. Note that the hanging indent is there as a hint that you can
  specify multiple source files in one "=target_source=" declaration.
- according to line [[(src_local)]] the file "=board_local.c=" will only be compiled
  if your current board is the board named "local".
- and you guessed it, line [[(src_native)]] makes sure that this source file is only
  considered when compiling for the "native_sim" board. Here I'd put the
  device-independent unit-tests, for example.

You can use the CONFIG_ ... variables also direcly in the sources:

#+begin_example c
#ifdef CONFIG_BOARD_LOCAL
   LOG_INF("Running on local")
endif
#+end_example

*** Configuration

You also learned about the various "=*.conf=" files like

- board-specific [[https://github.com/holgerschurig/zephyr-multi-board/blob/main/native_sim.conf][native_sim.conf]]
- board-specific [[https://github.com/holgerschurig/zephyr-multi-board/blob/main/nucleo_f303re.conf][nucleo_f303re.conf]]
- board-specific ones like [[https://github.com/holgerschurig/zephyr-multi-board/blob/main/boards/arm/local/Kconfig.board][boards/arm/local/Kconfig.board]], [[https://github.com/holgerschurig/zephyr-multi-board/blob/main/boards/arm/local/Kconfig_defconfig][boards/arm/local/Kconfig_defconfig]] and [[https://github.com/holgerschurig/zephyr-multi-board/blob/main/boards/arm/local/local_defconfig][boards/arm/local/local_defconfig]]
- the project-wide [[https://github.com/holgerschurig/zephyr-multi-board/blob/main/prj.conf][prj.conf]] file

But how to find out which "=CONFIG_*=" settings you can use?

Use either

- "=make menuconfig=" or
- "=make xconfig="

When you make changes there and save, you can then just run "=make=" to compile
your board with these settings. However, to make these changes permanent (and
thus reproducible), you need to update on of the configuration files I listed
above.

** Get help from make

I already showed "=make help_boards=". The same method (multiple pseudo makefile
targets emitting helpful text) is available to get an idea of what the Makefile can do for you:

#+begin_example
~/src/multi-board-zephyr$ make help
init                  do all of these steps:
   debs               only install debian packages
   venv               create and check Python3 virtual environment
   west               install and configure the 'west' tool
   zephyr             clone Zephyr
   modules            install Zeyphr modules (e.g. ST and STM32 HAL, CMSIS ...)
     module_stm32     update only STM32 HAL
     module_st        update only ST HAL
     module_cmsis     update only CMSIS

all                   compile for current board
menuconfig            run menuconfig for current board
xconfig               run xconfig for current board

native                configure and compile for native (used for unit-tests)
nucleo                configure and compile for STM32 Nucleo
local                 configure and compile for locally defined board
#+end_example

